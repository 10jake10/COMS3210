//Sean Fjellman    NetID: fjellman
//Jake Ebersole    NetID: jake001

// /share/cs321/legv8emul assignment1.legv8asm


//We are using an array size of 25
main:
SUBI SP, SP, #200
ADD X0, SP, XZR
ADDI X1, XZR, #25
BL fill

ADD X0, SP, XZR
ADDI X1, XZR, #25
BL issorted
PRNT X0   //this is correctly printing 0 because the array is not yet sorted

ADD X0, SP, XZR
ADDI X1, XZR, #25
BL stoopid_sort

ADD X0, SP, XZR
ADDI X1, XZR, #25
BL issorted
PRNT X0 //now this should print 1 because we have sorted

ADD X0, XZR, XZR //The C-program returns 0 wo we can too i guess
HALT

//------------------------------------------------------------------
fill:  //X0=*a, X1=n
SUBI X9, X1, #1  //X9 = i = n-1
top: 
// PRNT X9 //print i
SUB X10, X1, X9  //X10 = n-i
SUBI X10, X10, #1 //X10-1
LSL X10, X10, #3 //X10 *= 8
ADD X10, X10, X0 //X10 = &a[n-1-i]
// PRNT X10 //testing
// PRNT X9 //testing
STUR X9, [X10, #0] //a[n-1-i] = i

SUBIS X9, X9, #1 //i--
B.GE top
BR LR

//--------------------------------------------------------------------
maxIndex:
//X0 is array pointer
//X1 is n parameters
//X2 is m parameters

//X0 is return value

//A[n]
//shiftAmount = n * 8 for offset
//declaring n
LSL X9, X1, #3 //offset, remember what X1 is(Sean)
ADD X9, X0, X9 //adding Shift amount
LDUR X10, [X9, #0] //Loading the array value

//X10 = A[n]


//A[m] // exactly the same
LSL X11, X2, #3 //offset X11 = m * 8
ADD X11, X0, X11 //X11 = arrayPointer + offset
LDUR X12, [X11, #0]
//X12 = a[m]

// if a[n] > a[m]: return n else return m
SUBS XZR, X10, X12
B.GT greater_case


ADD X0, X2, XZR // returning m
BR LR

greater_case:
ADD X0, X1, XZR// returning n
BR LR


//-------------------------------------------------------------------------
issorted:
// x0 is a pointer to array a
// x1 is the number of elements

//Declaring n and setting it to 1
ADDI X9, XZR, #1
//PRNT X9

loop:
SUBS XZR, X9, X1
B.GE sorted


//Calculating the offsets
//gettin A[i] stored in X11
LSL X10, X9, #3 //multiply by 8 for the offset
ADD X10, X0, X10 //Recording the memory address
LDUR X11, [X10, #0] //Loading the value

//getting A[i -1] stored in X14
SUBI X12, X9, #1
LSL X13, X12, #3
ADD X13, X0, X13
LDUR X14, [X13, #0] //Loading the value

//SUBS XZR, X11, X14
SUBS XZR, X11, X14
B.LT unsorted


ADDI X9, X9, #1
B loop

//Returning 0 or 1
//@Sean I am reversing your outputs here so sorted=1 and unsorted=0 as is described in the piazza post

end:

sorted:

ADDI X0, XZR, #1
BR LR

unsorted:
ADDI X0, XZR, #0
BR LR

//----------------------------------------------------------------------
swap:
// X0 is address of a
// X1 is index i
// X2 is index j
// X9 will be temp register

LSL X1, X1, #3 //X1 *= 8
ADD X1, X1, X0  //X1 += &a = &a[i]

LSL X2, X2, #3 //X2 *= 8
ADD X2, X2, X0  //X2 += &a = &a[j]
LDUR X10, [X2, #0] //X10 = a[j]

LDUR X9, [X1, #0] //tmp = a[i]
STUR X10, [X1, #0] //a[i] = a[j];
STUR X9, [X2, #0] //a[j] = tmp;
BR LR


//-------------------------------------------------------------------------
find_largest:
// X0 is address of a
// X1 is start
// X2 is size

//if size==1, return
SUBIS XZR, X2, #1
B.EQ basecase

//Save LR, X0, X1, X2 in stack
SUBI SP, SP, #40
STUR LR, [SP, #0]
STUR X0, [SP, #8]
STUR X1, [SP, #16]
STUR X2, [SP, #24]

// compute find_largest(a, start, size / 2) and save values in stack
// temp X9 = size/2
LSR X2, X2, #1
BL find_largest
//save return value of first find_largest recursive call to stack
STUR X0, [SP, #32]

//Load arguments for second find_largest recursive call
LDUR X0, [SP, #8]
//temp X9 = start
//temp X10 = size
LDUR X9, [SP, #16]
LDUR X10, [SP, #24]
//X1 = start + size/2
LSR X1, X10, #1
ADD X1, X1, X9
//X2 = (size+1)/2
ADDI X2, X10, #1
LSR X2, X2, #1
BL find_largest

//Load arguments for max-index call
ADD X2, X0, XZR //third argument is result of second recursive call
LDUR X1, [SP, #32] //second argument is result of first recursive call
LDUR X0, [SP, #8] //first argument is stored address of a
BL maxIndex

//the result of the previous function call is our return value, so it can stay in X0

// restore LR and pop stack
LDUR LR, [SP, #0]
ADDI SP, SP, #40
BR LR

basecase:
ADD X0, X1, XZR //return start
BR LR

//----------------------------------------------------------------------------------
stoopid_sort:
// X0 is address of a
// X1 is size
// X9 is i
// X10 and X11 are temps

ADD X9, XZR, XZR //i = 0

//store LR, a, size, i in stack
SUBI SP, SP, #32
STUR LR, [SP, #0]
STUR X0, [SP, #8]
STUR X1, [SP, #16]
STUR X9, [SP, #24]

stoopid_sort_loop:

LDUR X9, [SP, #24] // X9 = i
LDUR X10, [SP, #16] //X10 = size
//Check loop condition
SUBI X11, X10, #1  //X11 = size-1
SUBS XZR, X9, X11
B.GE stoopid_sort_end

// Load find_largest arguments in
LDUR X0, [SP, #8] //first arg is a
ADD X1, XZR, XZR   //second arg is zero
SUB X2, X10, X9  //third arg is size - i
BL find_largest

//Load arguments for swap
ADD X1, X0, XZR  //second arg is result of find_largest
LDUR X0, [SP, #8] //first arg is a
LDUR X9, [SP, #24] //third arg is size-i-1
LDUR X2, [SP, #16] 
SUB X2, X2, X9
SUBI X2, X2, #1
BL swap

//increment and store i
LDUR X9, [SP, #24]
ADDI X9, X9, #1
STUR X9, [SP, #24]

//loop
B stoopid_sort_loop

stoopid_sort_end:
//restore LR and pop stack
LDUR LR, [SP, #0]
ADDI SP, SP, #32
BR LR

