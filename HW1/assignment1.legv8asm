// /share/cs321/legv8emul assignment1.legv8asm

main:
SUBI SP, SP, #200    //Space for 25 ints
// PRNT SP //test
ADD X0, SP, XZR
//ADDI X1, XZR, #25
ADDI X1, XZR, #2
//BL fill

//ADD X0, SP, XZR
//ADDI X1, XZR, #25
ADDI X9, XZR, #1
STUR X9, [X0, #0]

ADDI X9, XZR, #2
STUR X9, [X0, #8]

//Calling sorted
BL issorted
//PRNT X0
//DEBUG
HALT

fill:  //X0=*a, X1=n
SUBI X9, X1, #1  //X9 = i = n-1
top: 
// PRNT X9 //print i
SUB X10, X1, X9  //X10 = n-i
SUBI X10, X10, #1 //X10-1
LSL X10, X10, #3 //X10 *= 8
ADD X10, X10, X0 //X10 = &a[n-1-i]
// PRNT X10 //testing
// PRNT X9 //testing
STUR X9, [X10, #0] //a[n-1-i] = i

SUBIS X9, X9, #1 //i--
B.GE top

//end:
BR LR


maxIndex:
//X0 is array pointer
//X1 is n parameters
//X2 is m parameters

//X0 is return value

//A[n]
//shiftAmount = n * 8 for offset
//declaring n
LSL X9, X1, #3 //offset, remember what X1 is(Sean)
ADD X9, X0, X9 //adding Shift amount
LDUR X10, [X9, #0] //Loading the array value

//X10 = A[n]


//A[m] // exactly the same
LSL X11, X2, #3 //offset X11 = m * 8
ADD X11, X0, X11 //X11 = arrayPointer + offset
LDUR X12, [X11, #0]
//X12 = a[m]

// if a[n] > a[m]: return n else return m
SUBS XZR, X10, X12
B.GT greater_case


ADD X0, X2, XZR // returning m
BR LR

greater_case:
ADD X0, X1, XZR// returning n
BR LR



issorted:
// x0 is a pointer to array a
// x1 is the number of elements

//Declaring n and setting it to 1
ADDI X9, XZR, #1
//PRNT X9

loop:
SUBS XZR, X9, X1
B.GE sorted


//Calculating the offsets
//gettin A[i] stored in X11
LSL X10, X9, #3 //multiply by 8 for the offset
ADD X10, X0, X10 //Recording the memory address
LDUR X11, [X10, #0] //Loading the value

//getting A[i -1] stored in X14
SUBI X12, X9, #1
LSL X13, X12, #3
ADD X13, X0, X13
LDUR X14, [X13, #0] //Loading the value

//SUBS XZR, X11, X14
SUBS XZR, X11, X14
B.LT unsorted


ADDI X9, X9, #1
B loop

//Returning 0 or 1
//@Sean I am reversing your outputs here so sorted=1 and unsorted=0 as is described in the piazza post

end:

sorted:

ADDI X0, XZR, #1
BR LR

unsorted:
ADDI X0, XZR, #0
BR LR


swap:
// X0 is address of a
// X1 is index i
// X2 is index j
// X9 will be temp register

LSL X1, X1, #3 //X1 *= 8
ADD X1, X1, X0  //X1 += &a = &a[i]

LSL X2, X2, #3 //X2 *= 8
ADD X2, X2, X0  //X2 += &a = &a[j]
LDUR X10, [X2, #0] //X10 = a[j]

LDUR X9, [X1, #0] //tmp = a[i]
STUR X10, [X1, #0] //a[i] = a[j];
STUR X9, [X2, #0] //a[j] = tmp;
BR LR



find_largest:
// X0 is address of a
// X1 is start
// X2 is size

//if size==1, return
SUBIS XZR, X2, #1
B.EQ basecase

//Save LR, X0, X1, X2 in stack
SUBI SP, SP, #40
STUR LR, [SP, #0]
STUR X0, [SP, #8]
STUR X1, [SP, #16]
STUR X2, [SP, #24]

// compute find_largest(a, start, size / 2) and save values in stack
// temp X9 = size/2
LSR X2, X2, #1
BL find_largest
//save return value of first find_largest recursive call to stack
STUR X0, [SP, #32]

//Load arguments for second find_largest recursive call
LDUR X0, [SP, #8]
//temp X9 = start
//temp X10 = size
LDUR X9, [SP, #16]
LDUR X10, [SP, #24]
//X1 = start + size/2
LSR X1, X10, #1
ADD X1, X1, X9
//X2 = (size+1)/2
ADDI X2, X10, #1
LSR X2, X2, #1
BL find_largest

//Load arguments for max-index call
ADD X2, X0, XZR //third argument is result of second recursive call
LDUR X1, [SP, #32] //second argument is result of first recursive call
LDUR X0, [SP, #8] //first argument is stored address of a
BL maxIndex

//the result of the previous function call is our return value, so it can stay in X0

// restore LR and pop stack
LDUR LR, [SP, #0]
ADDI SP, SP, #40
BR LR

basecase:
ADD X0, X1, XZR //return start
BR LR
